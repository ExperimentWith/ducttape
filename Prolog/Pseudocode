def copy_graft_paths(grafts, nodes,edges):
    
    # TODO: Add sanity check to ensure that no branch point occurs more than once in grafts
    #       for example, do *not* allow grafting branchPointA:foo *and* branchPointB:bar 
    #                    on the same edge
    
    # graft is a tuple of the form (parent, child, via)
    #
    # via is a dictionary of the form:
    #    * key is a branch point
    #    * value is exactly one branch value
    #
    for graft in grafts:
    	# Parent is some sort of node.
    	# The copy of parent is also a node;
    	#     it will have the same type and label as the original parent
    	#     but the node's uid and node's via of the copy will be different from that of the parent
    	#
        create copy of parent with graft.via and add to nodes
        replace (parent,child) edge with (parent_copy,child) edge in edges
        replace child_via with graft_via
        unzip_graft(parent,parent_copy,graft_via,nodes,edges))

##########################################################################

def unzip_graft(node,node_copy,via,nodes,edges):
    
    if node has no parents:
        return

    elif node is a branch_point in via:
        create copy of correct parent with via
        add parent_copy to nodes
        add (parent_copy,node_copy) edge to edges
        unzip_graft(parent,parent_copy,via,nodes,edges)

    else:
        for each parent of node:
            create copy of parent with via
            add parent_copy to nodes
            add (parent_copy,node_copy) edge to edges
            unzip_graft(parent,parent_copy,via,nodes,edges)

##########################################################################

def unpack_one_possible_graph(goal_nodes,via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges):
    
    for goal_node in goal_nodes:
        unpack_node(goal_node,via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges)
   
    sorted_nodes = sorted(unpacked_nodes)
    nodes_to_keep = []
    node_attributes = []
    
    for node in sorted_nodes:
        if (original,type,label,via) in node_attributes:
            remove node from unpacked_nodes
            original_node = nodes_to_keep[index_in_node_attributes]
            for each child of node:
                replace (node,child) edge with (original_node,child) edge in unpacked_edges
        else:
            add node to nodes_to_keep
            add (original,type,label,via) to node_attributes

##########################################################################

def unpack_node(node,via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges):
    
    if node in unpacked_nodes:
        return
    
    elif node has no parents:
        merged_via = merge_vias(via,node_via)
        add node with merged_via to unpacked_nodes
    
    elif node is not a branch_point:
        merged_via = merge_vias(via,node_via)
        add node with merged_via to unpacked_nodes
        for each parent of node:
            add (parent,node) edge to unpacked_edges
            unpack_node(parent,merged_via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges)
    
    elif node is a branch_point that is not bound by a graft:
        merged_via = merge_vias(via,node_via)
        find branch value in via
        find parent with branch value
        add node with merged_via to unpacked_nodes
        add (parent,node) edge to unpacked_edges
        unpack_node(parent,merged_via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges)
    
    elif node is a branch_point that is bound by a graft:
        get parent
        merged_via = merge_vias(via,graft_via)
        add node with merged_via to unpacked_nodes
        add (parent,node) edge to unpacked edges
        unpack_node(parent,merged_via,packed_nodes,packed_edges,unpacked_nodes,unpacked_edges)

##########################################################################

def merge_vias(via1,via2):
    
    for branch_point in via1:
        if branch_point not in via2:
            via2[branch_point] = via1[branch_point]
    
    return via2

##########################################################################

def get_branch_combos(branch_points):
    combos = []
    vals = []
    
    for branch_point in branch_points:
        add branch_values to vals

    for value_combo in product(vals):
        add zipped branch_points and branch_values to combos

    return combos

    *or more succinctly*
    return [dict(zip(branch_points, branch_value)) for branch_value in product(*branch_points.values())]

##########################################################################

def find_branch_points(nodes,edges):
    
    branch_points = dict()
    
    for node in nodes:
        if node_type is branch_point:
            for each parent:
                add parent_label to branch_points[node_label]
		else:
			# Do some sort of error checking to ensure that all instances of this branch point 
			#    contain the same set of branch values
    
    return branch_points

##########################################################################

def find goal_nodes(nodes,edges):
    
    non_goal_nodes = set()
    goal_nodes = set()
    
    for (parent,child) in edges:
        add parent to non_goal_nodes
    
    for node in nodes:
        if node not in non_goal_nodes:
            add node to goal_nodes
    
    return goal_nodes

##########################################################################

main:

	# (node_id,node_id,node_type,node_label,dict())
	# node_id -> a unique node ID
	# node_id -> a copy of that unique node ID, will be changed later when copies are made
	# node_type -> one of branch, branch_point, task, etc
	# node_label -> for example, the name of the task
	# dict() -> starts out as an empty via dictionary; 
	#           as branches are encountered, the branch_point->branch assignments
	#           will be set in this dictionary
    read in nodes as (node_id,node_id,node_type,node_label,dict()) tuples
    
    # (parent_id,child_id) -> edges connecting parents and children
    read in edges as (parent_id,child_id) tuples
    
    # (parent_id,child_id,via)
    # Annotations on edges specifying grafting
    read in grafts as (parent_id,child_id,via) tuples,
        where via is a dict mapping each branch_point to a branch_value


	# At this point, we analyze the structure of the packed graph


	# Traverse the tree and identify all branch points 
	#    (and the corresponding branch values) that exist
	#
    branch_points = find_branch_points(nodes,edges)

    # Find all nodes which have no children
    #
    # Note: this does *not* look at the plan,
    #       just the topology of the graph
    #
    goal_nodes = find_goal_nodes(nodes,edges)

	
	# At this point, we start modifying the graph. 
	#
	# This will ultimately result in a transformation
	#    from a packed graph to an unpacked graph.


	# For each edge that is annotated with a graft,
	#    make a copy of the subtree rooted at that edge's child.
	#
	# Note: This process does *not* create a copy of the child.
	#
	# In that new copy, the newly created nodes are annotated
	#    with this graft information.
	#
    copy_graft_paths(grafts,nodes,edges)

    # Initialize an empty list wherein the unpacked graphs will be stored
    #
    unpacked_graphs = []

	# get_branch_combos(branch_points)
	#
	# This function takes a dictionary as input:
	#    the keys are all of the branch_points that exist in the graph
	#    the value for each key is the set of branch values that branch point can take
	#
	# The output is a set of dictionaries 
	#    representing the cross-product of all branch point/branch combinations.
	#
	# In this output, each dictionary is of the following form:
	#    the keys are all of the branch_points that exist in the graph
	#    the value for each key is exactly one of the branch values that branch point can take
	#
	#
	# for via in get_branch_combos(branch_points)
	#
	# We now take this set of dictionaries,
	#    and treat each individual dictionary as a via
	#
	# Note: At this point we are *not* actually consulting the list of vias from the plan
	#
    for via in get_branch_combos(branch_points):
    
    	# We will now attempt to construct exactly one unpacked graph,
    	#    namely, the unpacked graph corresponding to the current via.
    	
    	# Initialize an empty set of unpacked nodes and
    	#            an empty set of unpacked edges
        unpacked_nodes = set()
        unpacked_edges = set()
        
        # Given the leaf nodes (here called goal_nodes) and
        #       the current via and
        #       the set of packed nodes (after performing copying at graft points) and
        #       the set of packed edges (after performing copying at graft points) and
        #       the empty set of unpacked nodes and
        #       the empty set of unpacked edges
        # perform unpacking
        unpack_one_possible_graph(goal_nodes,via,nodes,edges,unpacked_nodes,unpacked_edges)
        
        # Store that particular unpacked graph
        unpacked_graphs.append((unpacked_nodes,unpacked_edges))

##########################################################################
