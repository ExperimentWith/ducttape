% !TEX TS-program = xelatexmk
% !TEX encoding = UTF-8 Unicode
%
% Compile this document using xelatex
\documentclass{report}

% Enable links in the PDF, but make them colored black
\usepackage[%
  colorlinks,
  linkcolor=black,
  anchorcolor=black,
  citecolor=black,
  filecolor=black,
  menucolor=black,
  runcolor=black,
  urlcolor=black,
  bookmarksopen=true,
  pdfpagelabels
]{hyperref}

% Make dates like this: 15 January 2013
\usepackage[english,cleanlook]{isodate}

% Make citations look like this: (Jones, 1979)
\usepackage{natbib}
\setcitestyle{round,semicolon}

% Make xelatex use latex mappings (such as --- for em-dash)
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text}

% redefine max depth of itemize
\usepackage{enumitem}
\setlistdepth{10}
\renewlist{itemize}{itemize}{10}

% Use Tikz to draw
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}


\title{Ducttape Technical Report}
\author{Lane Schwartz \and Jonathan Clark}

\begin{document}
\maketitle
\tableofcontents

\chapter{Motivation}

\citep{pedersen08}


\citep{deelmanetal09}

\citep{schwartz10} using GNU Make \citep{gnumake}

LoonyBin \citep{clarklavie10,clarketal10}

EMS \citep{koehn10ems}
  
Ducttape \citep{ducttape}

\chapter{The ducttape hyperworkflow language}

\chapter{HyperDAG theory}

\section{DAG --- directed acyclic graphs}

\section{HyperDAG --- directed acyclic hypergraphs}

\section{MetaHyperDAG --- directed acyclic hypergraphs with epsilon vertices}

\section{PhantomMetaHyperDAG --- directed acyclic hypergraphs with epsilon and phantom vertices }



\chapter{Building a workflow}

\section{Parsing a tape file}

Parsing is initiated by the ducttape main method through a call to \texttt{ducttape.syntax.\-GrammarParser.readWorkflow()}.
%
This causes the ducttape text file(s) to be parsed, ultimately resulting in an abstract syntax tree (AST).
%
\texttt{GrammarParser.readWorkflow()} calls \texttt{GrammarParser.parseAll()} to perform the actual parsing.
%
The result of is a sequence of objects directly representing the elements in the tape file;
the type of each element is \texttt{ducttape.syntax.ASTType}.

This list of elements is used to construct a \texttt{ducttape.syntax.WorkflowDefinition} object.
%
The ducttape main method similarly reads and parses any config files specified by the user, resulting in other \texttt{WorkflowDefinition} object(s).
%
All \texttt{WorkflowDefinition} objects are concatenated together into a single object --- \texttt{val wd: WorkflowDefinition}.
%
This object is error-checked by \texttt{StaticChecker} and by \texttt{WorkflowChecker}.

Finally, the \texttt{WorkflowDefinition} is used to construct a \texttt{ducttape.workflow.\-builder.WorkflowBuilder}.
%
The \texttt{WorkflowBuilder.build()} method is responsible for converting the AST into a \texttt{HyperWorkflow}.

%\begin{enumerate}
%\item 
%\end{enumerate} 


\section{Branch points and branches}
\label{sec:branchpoints_branches}
The \texttt{WorkflowBuilder.build()} method begins by traversing the abstract syntax tree represented by the \texttt{WorkflowDefinition}, looking for branch points and branches.
%
\texttt{WorkflowBuilder} has member variables \texttt{branchPointFactory} and \texttt{branchFactory} that maintain maps from branch point names to \texttt{BranchPoint} objects and branch names to \texttt{Branch} objects, respectively.
%
This traversal is performed by the inner method \texttt{findBranchPoints}.
%
After \texttt{findBranchPoints} is run, \texttt{branchPointFactory} and \texttt{branchFactory} have been populated with all branch points and branches in the workflow.

%
%\begin{enumerate}
%
%\item Traverse the AST to identify all branch points used in the workflow 
%      (see \texttt{findBranchPoints()} in \texttt{WorkflowBuilder.build()}; also 
%       see \texttt{BranchPoint} and \texttt{BranchPointFactory})
%
%\item For each branch point, identify all branch names associated with that branch point 
%      (see \texttt{Branch} and \texttt{BranchFactory}, especially \texttt{BranchFactory.getAll()})
%
%\end{enumerate}


\section{Building task templates}
\label{sec:buildTaskTemplates}

After identifying branch points and branches (\S\ref{sec:branchpoints_branches}), the \texttt{WorkflowBuilder.build()} method next constructs a \texttt{TaskTemplateBuilder} object from the \texttt{WorkflowDefinition}, the \texttt{BranchPointFactory}, and the \texttt{BranchFactory}.
%


\subsection{Find tasks}

After creating a \texttt{TaskTemplateBuilder} (\S\ref{sec:buildTaskTemplates}), the \texttt{WorkflowBuilder.build()} method calls \texttt{TaskTemplateBuilder.findTasks()}.
%
The \texttt{TaskTemplateBuilder.findTasks()} method is responsible for identifying temporal and structural dependencies among tasks and store those dependencies as an edge map; this method is also responsible for pre-resolving any non-temporal dependencies such as parameters.

%See \texttt{TaskTemplateBuilder.findTasks()}, called from \texttt{WorkflowBuilder.build()}

The \texttt{TaskTemplateBuilder.findTasks()} method performs the following actions:

\begin{enumerate}

\item The \texttt{findTasks()} method first gather a list of all task definitions present in the \texttt{WorkflowDefinition}. This includes regular task definitions as well as task definitions constructed by function calls.

\item By iterating over this list of task definitions, the \texttt{findTasks()} method next constructs a map where 
      the keys are globally unique task names and 
      the values are task definitions --- \texttt{taskMap: Map[Namespace,TaskDef]}.

\item For each task, iterate over all input specifications and parameter specifications for that task
      (see \texttt{TaskTemplateBuilder.findTasks()})

\item This step is extremely complicated and involves several mutually recursive functions.
      For each input specification and parameter specification in a task, 
      collect the set of possible values that each input and parameter can take. 
      This set of possible values will be recorded as a \texttt{BranchPointTree}.
      See \texttt{TaskTemplateBuilder.resolveBranchPoint()}, called from \texttt{TaskTemplateBuilder.findTasks()}.
      
\item BranchGraft elements are currently handled within \texttt{TaskTemplateBuilder.resolveNonBranchVar()}

\end{enumerate}

This results in a \texttt{TaskTemplateBuilder.parents} map, with task names as keys, and values as follows:

\begin{description}
\item[\texttt{BranchPointTreeGrafts}] The subtree for each task
    \begin{description}
    \item[\texttt{Seq[Branch]}] The set of grafts for this task
    \item[\texttt{BranchPointTree}] Maps the branch point name to its corresponding branches
        \begin{description}
        \item[\texttt{Baseline}] Each task has a \texttt{Baseline} branch point.
        \item[\texttt{BranchTree}] The subtree of the branch point
            \begin{description}
            \item[\texttt{Baseline.baseline}] Each \texttt{Baseline} branch point has a \texttt{baseline} branch
                \begin{description}
                \item[\texttt{Children}] An \texttt{ArrayBuffer[BranchPointTreeGrafts]} denoting nested branch points
                \item[\texttt{TerminalData}] Only leaves have \texttt{TerminalData}, one for each task dependency
                    \begin{description}
                    \item[\texttt{task}] The task these specs depend on
                    \item[\texttt{grafts}] Any grafts that were applied to these specs
                    \item[\texttt{isParam}] True if the dependency is literal, false if temporal
                    \item[\texttt{specs}] Used to resolve literals
                        \begin{description}
                        \item[\texttt{origSpec}] The variable name
                        \item[\texttt{srcTask}] The source task of the value
                        \item[\texttt{srcSpec}] The value assigned to the variable
                        \end{description}
                    \end{description}
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{description}



\section{Temporal and structural dependencies}

\section{Constructing a packed hyperDAG}

See \texttt{WorkflowBuilder.build()}

\begin{enumerate}

\item For each task template, create a vertex. Store these vertices in a map, where the keys are globally-unique task names.

\item Add Hyperedges by calling \texttt{WorkflowBuilder.traverse} on each vertex. \texttt{traverse} is mutually recursive with
      \texttt{getHyperedges}, which adds a phantom vertex (and edge) and \texttt{traverse}s that vertex if it encounters a
      nested branch point. If it does not encounter a nested branch point, \texttt{getHyperedges} adds a phantom vertex (and
      edge) for vertices with no temporal dependencies and a normal edge for vertices with temporal dependencies. In either
      case, the recursion succeeds, and we are done \texttt{traverse}-ing. The resulting vertices and hyperedges for our minimal
      tape is given in FigureSomethingOrOther, in which directed arrows represent normal edges, and non-directed arrows denote
      phantom edges.

\begin{tikzpicture}[node distance=1.3cm,>=stealth',bend angle=45,auto]

  \tikzstyle{branch}=[circle,thick,draw=black!75,fill=blue!20,minimum size=6mm]
  \tikzstyle{branchpoint}=[place,draw=black!75,fill=red!20]
  \tikzstyle{task}=[rectangle,thick,draw=black!75,fill=black!20,minimum size=4mm]
  \tikzstyle{param}=[rectangle,thick,draw=black!75,fill=green!20,minimum size=4mm]
  \tikzstyle{input}=[rectangle,thick,draw=black!75,fill=white!20,minimum size=4mm]

  \node [task]  (t1)                                    {parent1};
  \node [param] (p1)   [above of=t1]                    {"z=\'zazz\'"};

  \node [task] (t2)    [right of =t1]                   {hello};
  \node [input] (p2)   [above of=t2]                    {in};

  \draw [-] (p1) -- (t1);
  \draw [->] (p2) -- (t2);

\end{tikzpicture}

\item metaedges

\end{enumerate}


\bibliographystyle{plainnat}
\bibliography{report}

\end{document}

