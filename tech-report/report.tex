% !TEX TS-program = xelatexmk
% !TEX encoding = UTF-8 Unicode
%
% Compile this document using xelatex
\documentclass{report}

% Enable links in the PDF, but make them colored black
\usepackage[%
  colorlinks,
  linkcolor=black,
  anchorcolor=black,
  citecolor=black,
  filecolor=black,
  menucolor=black,
  runcolor=black,
  urlcolor=black,
  bookmarksopen=true,
  pdfpagelabels
]{hyperref}

% Make dates like this: 15 January 2013
\usepackage[english,cleanlook]{isodate}

% Make citations look like this: (Jones, 1979)
\usepackage{natbib}
\setcitestyle{round,semicolon}

% Make xelatex use latex mappings (such as --- for em-dash)
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text}

% redefine max depth of itemize
\usepackage{enumitem}
\setlistdepth{10}
\renewlist{itemize}{itemize}{10}

% Use Tikz to draw
\usepackage{tikz}
\usetikzlibrary{arrows,shapes,snakes,automata,backgrounds,petri}
\usepackage[forceshell,outputdir={auto_generated/}]{dot2texi}

\title{Ducttape Technical Report}
\author{Lane Schwartz \and Jonathan Clark}

\begin{document}
\maketitle
\tableofcontents

\chapter{Motivation}

\citep{pedersen08}


\citep{deelmanetal09}

\citep{schwartz10} using GNU Make \citep{gnumake}

LoonyBin \citep{clarklavie10,clarketal10}

EMS \citep{koehn10ems}
  
Ducttape \citep{ducttape}

\chapter{The ducttape hyperworkflow language}

\chapter{HyperDAG theory}

\section{DAG --- directed acyclic graphs}

\section{HyperDAG --- directed acyclic hypergraphs}

\section{MetaHyperDAG --- directed acyclic hypergraphs with epsilon vertices}

\section{PhantomMetaHyperDAG --- directed acyclic hypergraphs with epsilon and phantom vertices }



\chapter{Building a workflow}

\section{Parsing a tape file}

Parsing is initiated by the ducttape main method through a call to \texttt{ducttape.syntax.\-GrammarParser.readWorkflow()}.
%
This causes the ducttape text file(s) to be parsed, ultimately resulting in an abstract syntax tree (AST).
%
\texttt{GrammarParser.readWorkflow()} calls \texttt{GrammarParser.parseAll()} to perform the actual parsing.
%
The result of is a sequence of objects directly representing the elements in the tape file;
the type of each element is \texttt{ducttape.syntax.ASTType}.

This list of elements is used to construct a \texttt{ducttape.syntax.WorkflowDefinition} object.
%
The ducttape main method similarly reads and parses any config files specified by the user, resulting in other \texttt{WorkflowDefinition} object(s).
%
All \texttt{WorkflowDefinition} objects are concatenated together into a single object --- \texttt{val wd: WorkflowDefinition}.
%
This object is error-checked by \texttt{StaticChecker} and by \texttt{WorkflowChecker}.

Finally, the \texttt{WorkflowDefinition} is used to construct a \texttt{ducttape.workflow.\-builder.WorkflowBuilder}.
%
The \texttt{WorkflowBuilder.build()} method is responsible for converting the AST into a \texttt{HyperWorkflow}.

%\begin{enumerate}
%\item 
%\end{enumerate} 


\section{Branch points and branches}
\label{sec:branchpoints_branches}
The \texttt{WorkflowBuilder.build()} method begins by traversing the abstract syntax tree represented by the \texttt{WorkflowDefinition}, looking for branch points and branches.
%
\texttt{WorkflowBuilder} has member variables \texttt{branchPointFactory} and \texttt{branchFactory} that maintain maps from branch point names to \texttt{BranchPoint} objects and branch names to \texttt{Branch} objects, respectively.
%
This traversal is performed by the inner method \texttt{findBranchPoints}.
%
After \texttt{findBranchPoints} is run, \texttt{branchPointFactory} and \texttt{branchFactory} have been populated with all branch points and branches in the workflow.

%
%\begin{enumerate}
%
%\item Traverse the AST to identify all branch points used in the workflow 
%      (see \texttt{findBranchPoints()} in \texttt{WorkflowBuilder.build()}; also 
%       see \texttt{BranchPoint} and \texttt{BranchPointFactory})
%
%\item For each branch point, identify all branch names associated with that branch point 
%      (see \texttt{Branch} and \texttt{BranchFactory}, especially \texttt{BranchFactory.getAll()})
%
%\end{enumerate}


\section{Building task templates}
\label{sec:buildTaskTemplates}

After identifying branch points and branches (\S\ref{sec:branchpoints_branches}), the \texttt{WorkflowBuilder.build()} method next constructs a \texttt{TaskTemplateBuilder} object from the \texttt{WorkflowDefinition}, the \texttt{BranchPointFactory}, and the \texttt{BranchFactory}.
%


\subsection{Find tasks}

After creating a \texttt{TaskTemplateBuilder} (\S\ref{sec:buildTaskTemplates}), the \texttt{WorkflowBuilder.build()} method calls \texttt{TaskTemplateBuilder.findTasks()}.
%
The \texttt{TaskTemplateBuilder.findTasks()} method is responsible for identifying temporal and structural dependencies among tasks and store those dependencies as an edge map; this method is also responsible for pre-resolving any non-temporal dependencies such as parameters.

%See \texttt{TaskTemplateBuilder.findTasks()}, called from \texttt{WorkflowBuilder.build()}

The \texttt{TaskTemplateBuilder.findTasks()} method performs the following actions:

\begin{enumerate}

\item The \texttt{findTasks()} method first gather a list of all task definitions present in the \texttt{WorkflowDefinition}. This includes regular task definitions as well as task definitions constructed by function calls.

\item By iterating over this list of task definitions, the \texttt{findTasks()} method next constructs a map where 
      the keys are globally unique task names and 
      the values are task definitions --- \texttt{taskMap: Map[Namespace,TaskDef]}.

\item For each task, iterate over all input specifications and parameter specifications for that task
      (see \texttt{TaskTemplateBuilder.findTasks()})

\item This step is extremely complicated and involves several mutually recursive functions.
      For each input specification and parameter specification in a task, 
      collect the set of possible values that each input and parameter can take. 
      This set of possible values will be recorded as a \texttt{BranchPointTree}.
      See \texttt{TaskTemplateBuilder.resolveBranchPoint()}, called from \texttt{TaskTemplateBuilder.findTasks()}.
      
\item BranchGraft elements are currently handled within \texttt{TaskTemplateBuilder.resolveNonBranchVar()}

\end{enumerate}

This results in a \texttt{TaskTemplateBuilder.parents} map, with task names as keys, and values as follows:

\begin{description}
\item[\texttt{BranchPointTreeGrafts}] The subtree for each task
    \begin{description}
    \item[\texttt{Seq[Branch]}] The set of grafts for this task
    \item[\texttt{BranchPointTree}] Maps the branch point name to its corresponding branches
        \begin{description}
        \item[\texttt{Baseline}] Each task has a \texttt{Baseline} branch point.
        \item[\texttt{BranchTree}] The subtree of the branch point
            \begin{description}
            \item[\texttt{Baseline.baseline}] Each \texttt{Baseline} branch point has a \texttt{baseline} branch
                \begin{description}
                \item[\texttt{Children}] An \texttt{ArrayBuffer[BranchPointTreeGrafts]} denoting nested branch points
                \item[\texttt{TerminalData}] Only leaves have \texttt{TerminalData}, one for each task dependency
                    \begin{description}
                    \item[\texttt{task}] The task these specs depend on
                    \item[\texttt{grafts}] Any grafts that were applied to these specs
                    \item[\texttt{isParam}] True if the dependency is literal, false if temporal
                    \item[\texttt{specs}] Used to resolve literals
                        \begin{description}
                        \item[\texttt{origSpec}] The variable name
                        \item[\texttt{srcTask}] The source task of the value
                        \item[\texttt{srcSpec}] The value assigned to the variable
                        \end{description}
                    \end{description}
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{description}



\section{Temporal and structural dependencies}

\section{Constructing a packed hyperDAG}

See \texttt{WorkflowBuilder.build()} 

For illustrative purposes, the following section discusses output for the following minimal \texttt{.tape} file:

\begin{quotation}
	global {
		\quad foo="bar"
	}
	
	task parent1 :: z="zazz" {}
	
	task parent2 :: q=(Q: q1="qiikw" q2="qikmiq" q3=(Sky: blue red=\$z@parent1)) {}
	
	task hello :: a="abc" b=\$foo c=\$z@parent1 myq=\$q@parent2 > out {
		\quad echo "Hello" > \${out}
	}
	
	task world < in=\$out@hello > out2 {
		\quad echo "World" > \${out2}
	}
	
	plan {
	
		\quad reach world via (Q: *) * (Sky: *)
	
	}
\end{quotation}

\begin{enumerate}

\item For each task template, create a vertex. Store these vertices in a map, where the keys are globally-unique task names.
      We create vertices by calling \texttt{addVertex} on the \texttt{PhantomMetaHyperDagBuilder}, which in turn calls \texttt{addVertex}
      on the \texttt{MetaHyperDagBuilder}, which calls \texttt{addVertex} on the \texttt{HyperDagBuilder}. \texttt{HyperDagBuilder.addVertex}
      then creates a \texttt{PackedVertex} and adds it to the HyperDag. We add phantom vertices in much the same way, but pass \texttt{None}
      instead of a \texttt{TaskTemplate}.

\item Find Hyperedges by calling \texttt{WorkflowBuilder.traverse} on each newly-created vertex. \texttt{traverse} is mutually recursive with
      \texttt{getHyperedges}, which adds a phantom vertex (and edge) and \texttt{traverse}s that vertex if it encounters a
      nested branch point. If it does not encounter a nested branch point, \texttt{getHyperedges} adds a phantom vertex (and
      edge) for vertices with no temporal dependencies and a normal edge for vertices with temporal dependencies. In either
      case, the recursion succeeds, and we are done \texttt{traverse}-ing. The resulting vertices and hyperedges for our minimal
      tape is given in FigureSomethingOrOther, in which green nodes denote normal vertices, blue nodes denote phantom vertices, dark gray
      nodes denote branches, and edges are annotated with \texttt{SpecGroup}s.

\tikzstyle{vertex}=[rectangle,thick,draw=black!75,fill=green!20]
\tikzstyle{phantom}=[rectangle,thick,draw=black!75,fill=blue!20]
\tikzstyle{epsilon}=[rectangle,thick,draw=black!75,fill=red!20]
\tikzstyle{branch}=[rectangle,thick,draw=black!75,fill=black!20]
\tikzstyle{spec}=[rectangle,thick,draw=black!75,fill=black!5]

\begin{tikzpicture}[>=latex, scale=0.5, transform shape]
\begin{dot2tex}[dot,tikzedgelabels,codeonly]

digraph G {

  graph [nodesep="1", ranksep="1"];

  v00 [style="vertex", label="parent1"];
  v01 [style="vertex", label="parent2"];
  v02 [style="vertex", label="hello"];
  v03 [style="vertex", label="world"];
  v04 [style="phantom", label="parent1.literals"];
  v06 [style="phantom", label="world.literals"];
  v08 [style="phantom", label="hello.literals"];
  v09 [style="phantom", label="hello.Baseline.baseline.nestedBranch[]"];
  v10 [style="phantom", label="hello.Q.q3.nestedBranch[]"];
  v14 [style="phantom", label="parent2.literals"];
  v15 [style="phantom", label="parent2.Baseline.baseline.nestedBranch[]"];
  v16 [style="phantom", label="parent2.Q.q3.nestedBranch"];
  
  b01 [style="branch", label="Sky.blue"];
  b02 [style="branch", label="Sky.red"];
  b03 [style="branch", label="Baseline.baseline"];
  b04 [style="branch", label="Q.q1"];
  b05 [style="branch", label="Q.q2"];
  b06 [style="branch", label="Q.q3"];

  b03 -> v04 [label="z='zazz'@", lblstyle="spec"];

  b03 -> v02 [label="in=@hello", lblstyle="spec"];

  b01 -> v08 [label="myq='blue'@parent2", lblstyle="spec"];
  b02 -> v08 [label="myq='zazz'@parent1", lblstyle="spec"];
  b04 -> v08 [label="myq='qiikw'@parent2", lblstyle="spec"];
  b05 -> v08 [label="myq='qikmiq'@parent2", lblstyle="spec"];
  b06 -> v10 [label="empty", lblstyle="spec"];
  b03 -> v09 [label="empty", lblstyle="spec"];
  b03 -> v08 [label="a='abc'@,b='bar'@", lblstyle="spec"];
  b03 -> v08 [label="c='zazz'@parent1", lblstyle="spec"];

  b01 -> v14 [label="q='blue'@", lblstyle="spec"];
  b02 -> v14 [label="q='zazz'@parent1", lblstyle="spec"];
  b04 -> v14 [label="q='qiikw'@", lblstyle="spec"];
  b05 -> v14 [label="q='qikmiq'@", lblstyle="spec"];
  b06 -> v16 [label="empty", lblstyle="spec"];
  b03 -> v15 [label="empty", lblstyle="spec"];

}

\end{dot2tex}
\end{tikzpicture}

\item When we are finished finding hyperedges for the task, we call \texttt{addMetaEdge} on the \texttt{PhantomMetaHyperDagBuilder},
      which calls \texttt{addMetaEdge} on the \texttt{MetaHyperDagBuilder}. \texttt{MetaHyperDagBuilder.addMetaEdge} adds an
      epsilon vertex and a \texttt{HyperEdge} to the \texttt{HyperDagBuilder}. Epsilon vertices pair each task with its respective
      branch points. Our minimal example produces eight epsilon vertices: a \texttt{Baseline:task} vertex for each task, \texttt{Q:task}
      vertices for \texttt{hello} and \texttt{parent2}, and \texttt{Sky:task} vertices for \texttt{hello} and \texttt{parent2}. 

\begin{tikzpicture}[>=latex, scale=0.5, transform shape]
\begin{dot2tex}[dot,tikzedgelabels,codeonly]

digraph G {

  graph [nodesep="1", ranksep="1"];

  v00 [style="vertex", label="parent1"];
  v01 [style="vertex", label="parent2"];
  v02 [style="vertex", label="hello"];
  v03 [style="vertex", label="world"];
  v04 [style="phantom", label="parent1.literals"];
  v05 [style="epsilon", label="Baseline:parent1"];
  v06 [style="phantom", label="world.literals"];
  v07 [style="epsilon", label="Baseline:world"];
  v08 [style="phantom", label="hello.literals"];
  v09 [style="phantom", label="hello.Baseline.baseline.nestedBranch[]"];
  v10 [style="phantom", label="hello.Q.q3.nestedBranch[]"];
  v11 [style="epsilon", label="Sky:hello"];
  v12 [style="epsilon", label="Q:hello"];
  v13 [style="epsilon", label="Baseline:hello"];
  v14 [style="phantom", label="parent2.literals"];
  v15 [style="phantom", label="parent2.Baseline.baseline.nestedBranch[]"];
  v16 [style="phantom", label="parent2.Q.q3.nestedBranch"];
  v17 [style="epsilon", label="Sky:parent2"];
  v18 [style="epsilon", label="Q:parent2"];
  v19 [style="epsilon", label="Baseline:parent2"];

  b01 [style="branch", label="Sky.blue"];
  b02 [style="branch", label="Sky.red"];
  b03 [style="branch", label="Baseline.baseline"];
  b04 [style="branch", label="Q.q1"];
  b05 [style="branch", label="Q.q2"];
  b06 [style="branch", label="Q.q3"];

  b03 -> v04 [label="z='zazz'@", lblstyle="spec"];

  b03 -> v02 [label="in=@hello", lblstyle="spec"];

  b01 -> v08 [label="myq='blue'@parent2", lblstyle="spec"];
  b02 -> v08 [label="myq='zazz'@parent1", lblstyle="spec"];
  b04 -> v08 [label="myq='qiikw'@parent2", lblstyle="spec"];
  b05 -> v08 [label="myq='qikmiq'@parent2", lblstyle="spec"];
  b06 -> v10 [label="empty", lblstyle="spec"];
  b03 -> v09 [label="empty", lblstyle="spec"];
  b03 -> v08 [label="a='abc'@,b='bar'@", lblstyle="spec"];
  b03 -> v08 [label="c='zazz'@parent1", lblstyle="spec"];

  b01 -> v14 [label="q='blue'@", lblstyle="spec"];
  b02 -> v14 [label="q='zazz'@parent1", lblstyle="spec"];
  b04 -> v14 [label="q='qiikw'@", lblstyle="spec"];
  b05 -> v14 [label="q='qikmiq'@", lblstyle="spec"];
  b06 -> v16 [label="empty", lblstyle="spec"];
  b03 -> v15 [label="empty", lblstyle="spec"];

  v04 -> v05 [label="z='zazz'@", lblstyle="spec"];
  v02 -> v07 [label="in=@hello", lblstyle="spec"];

}

\end{dot2tex}
\end{tikzpicture}

\end{enumerate}


\bibliographystyle{plainnat}
\bibliography{report}

\end{document}

