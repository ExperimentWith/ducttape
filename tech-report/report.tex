% !TEX TS-program = xelatexmk
% !TEX encoding = UTF-8 Unicode
%
% Compile this document using xelatex
\documentclass{report}

% Enable links in the PDF, but make them colored black
\usepackage[%
  colorlinks,
  linkcolor=black,
  anchorcolor=black,
  citecolor=black,
  filecolor=black,
  menucolor=black,
  runcolor=black,
  urlcolor=black,
  bookmarksopen=true,
  pdfpagelabels
]{hyperref}

% Make dates like this: 15 January 2013
\usepackage[english,cleanlook]{isodate}

% Make citations look like this: (Jones, 1979)
\usepackage{natbib}
\setcitestyle{round,semicolon}

% Make xelatex use latex mappings (such as --- for em-dash)
\usepackage{fontspec}
\defaultfontfeatures{Mapping=tex-text}

% redefine max depth of itemize
\usepackage{enumitem}
\setlistdepth{10}
\renewlist{itemize}{itemize}{10}

\title{Ducttape Technical Report}
\author{Lane Schwartz \and Jonathan Clark}

\begin{document}
\maketitle
\tableofcontents

\chapter{Motivation}

\citep{pedersen08}


\citep{deelmanetal09}

\citep{schwartz10} using GNU Make \citep{gnumake}

LoonyBin \citep{clarklavie10,clarketal10}

EMS \citep{koehn10ems}
  
Ducttape \citep{ducttape}

\chapter{The ducttape hyperworkflow language}

\chapter{HyperDAG theory}

\section{DAG --- directed acyclic graphs}

\section{HyperDAG --- directed acyclic hypergraphs}

\section{MetaHyperDAG --- directed acyclic hypergraphs with epsilon vertices}

\section{PhantomMetaHyperDAG --- directed acyclic hypergraphs with epsilon and phantom vertices }



\chapter{Building a workflow}

\section{Parsing a tape file}

Parsing is initiated by the ducttape main method through a call to \texttt{ducttape.syntax.\-GrammarParser.readWorkflow()}.
%
This causes the ducttape text file(s) to be parsed, ultimately resulting in an abstract syntax tree (AST).
%
\texttt{GrammarParser.readWorkflow()} calls \texttt{GrammarParser.parseAll()} to perform the actual parsing.
%
The result of is a sequence of objects directly representing the elements in the tape file;
the type of each element is \texttt{ducttape.syntax.ASTType}.

This list of elements is used to construct a \texttt{ducttape.syntax.WorkflowDefinition} object.
%
The ducttape main method similarly reads and parses any config files specified by the user, resulting in other \texttt{WorkflowDefinition} object(s).
%
All \texttt{WorkflowDefinition} objects are concatenated together into a single object --- \texttt{val wd: WorkflowDefinition}.
%
This object is error-checked by \texttt{StaticChecker} and by \texttt{WorkflowChecker}.

Finally, the \texttt{WorkflowDefinition} is used to construct a \texttt{ducttape.workflow.\-builder.WorkflowBuilder}.
%
The \texttt{WorkflowBuilder.build()} method is responsible for converting the AST into a \texttt{HyperWorkflow}.

%\begin{enumerate}
%\item 
%\end{enumerate} 


\section{Branch points and branches}
\label{sec:branchpoints_branches}
The \texttt{WorkflowBuilder.build()} method begins by traversing the abstract syntax tree represented by the \texttt{WorkflowDefinition}, looking for branch points and branches.
%
\texttt{WorkflowBuilder} has member variables \texttt{branchPointFactory} and \texttt{branchFactory} that maintain maps from branch point names to \texttt{BranchPoint} objects and branch names to \texttt{Branch} objects, respectively.
%
This traversal is performed by the inner method \texttt{findBranchPoints}.
%
After \texttt{findBranchPoints} is run, \texttt{branchPointFactory} and \texttt{branchFactory} have been populated with all branch points and branches in the workflow.

%
%\begin{enumerate}
%
%\item Traverse the AST to identify all branch points used in the workflow 
%      (see \texttt{findBranchPoints()} in \texttt{WorkflowBuilder.build()}; also 
%       see \texttt{BranchPoint} and \texttt{BranchPointFactory})
%
%\item For each branch point, identify all branch names associated with that branch point 
%      (see \texttt{Branch} and \texttt{BranchFactory}, especially \texttt{BranchFactory.getAll()})
%
%\end{enumerate}


\section{Building task templates}
\label{sec:buildTaskTemplates}

After identifying branch points and branches (\S\ref{sec:branchpoints_branches}), the \texttt{WorkflowBuilder.build()} method next constructs a \texttt{TaskTemplateBuilder} object from the \texttt{WorkflowDefinition}, the \texttt{BranchPointFactory}, and the \texttt{BranchFactory}.
%


\subsection{Find tasks}

After creating a \texttt{TaskTemplateBuilder} (\S\ref{sec:buildTaskTemplates}), the \texttt{WorkflowBuilder.build()} method calls \texttt{TaskTemplateBuilder.findTasks()}.
%
The \texttt{TaskTemplateBuilder.findTasks()} method is responsible for identifying temporal and structural dependencies among tasks and store those dependencies as an edge map; this method is also responsible for pre-resolving any non-temporal dependencies such as parameters.

%See \texttt{TaskTemplateBuilder.findTasks()}, called from \texttt{WorkflowBuilder.build()}

The \texttt{TaskTemplateBuilder.findTasks()} method performs the following actions:

\begin{enumerate}

\item The \texttt{findTasks()} method first gather a list of all task definitions present in the \texttt{WorkflowDefinition}. This includes regular task definitions as well as task definitions constructed by function calls.

\item By iterating over this list of task definitions, the \texttt{findTasks()} method next constructs a map where 
      the keys are globally unique task names and 
      the values are task definitions --- \texttt{taskMap: Map[Namespace,TaskDef]}.

\item For each task, iterate over all input specifications and parameter specifications for that task
      (see \texttt{TaskTemplateBuilder.findTasks()})

\item This step is extremely complicated and involves several mutually recursive functions.
      For each input specification and parameter specification in a task, 
      collect the set of possible values that each input and parameter can take. 
      This set of possible values will be recorded as a \texttt{BranchPointTree}.
      See \texttt{TaskTemplateBuilder.resolveBranchPoint()}, called from \texttt{TaskTemplateBuilder.findTasks()}.
      
\item BranchGraft elements are currently handled within \texttt{TaskTemplateBuilder.resolveNonBranchVar()}

\end{enumerate}

This results in a \texttt{TaskTemplateBuilder.parents} map, with task names as keys, and values as follows:

\begin{description}
\item[\texttt{BranchPointTreeGrafts}] The subtree for each task
    \begin{description}
    \item[\texttt{Seq[Branch]}] The set of grafts for this task
    \item[\texttt{BranchPointTree}] Maps the branch point name to its corresponding branches
        \begin{description}
        \item[\texttt{Baseline}] Each task has a \texttt{Baseline} branch point.
        \item[\texttt{BranchTree}] The subtree of the branch point
            \begin{description}
            \item[\texttt{Baseline.baseline}] Each \texttt{Baseline} branch point has a \texttt{baseline} branch
                \begin{description}
                \item[\texttt{Children}] An \texttt{ArrayBuffer[BranchPointTreeGrafts]} denoting nested branch points
                \item[\texttt{TerminalData}] Only leaves have \texttt{TerminalData}, one for each task dependency
                    \begin{description}
                    \item[\texttt{task}] The task these specs depend on
                    \item[\texttt{grafts}] Any grafts that were applied to these specs
                    \item[\texttt{isParam}] True if the dependency is literal, false if temporal
                    \item[\texttt{specs}] Used to resolve literals
                        \begin{description}
                        \item[\texttt{origSpec}] The variable name
                        \item[\texttt{srcTask}] The source task of the value
                        \item[\texttt{srcSpec}] The value assigned to the variable
                        \end{description}
                    \end{description}
                \end{description}
            \end{description}
        \end{description}
    \end{description}
\end{description}



\section{Temporal and structural dependencies}

\section{Constructing a packed hyperDAG}

See \texttt{WorkflowBuilder.build()} 

For illustrative purposes, the following section discusses output for the following minimal \texttt{.tape} file:

\begin{verbatim}
    global {
        foo="bar"
    }
	
    task parent1 :: z="zazz" {}
	
    task parent2 :: q=(Q: q1="qiikw" q2="qikmiq" q3=(Sky: blue red=\$z@parent1)) {}
	
    task hello :: a="abc" b=\$foo c=\$z@parent1 myq=\$q@parent2 > out {
        echo "Hello" > \${out}
    }
	
    task world < in=\$out@hello > out2 {
        echo "World" > \${out2}
    }
	
    plan {
        reach world via (Q: *) * (Sky: *)
    }
\end{verbatim}

\begin{enumerate}

\item For each task template, create a vertex. Store these vertices in a map, where the keys are globally-unique task names.
      We create vertices by calling \texttt{addVertex} on the \texttt{PhantomMetaHyperDagBuilder}, which in turn calls \texttt{addVertex}
      on the \texttt{MetaHyperDagBuilder}, which calls \texttt{addVertex} on the \texttt{HyperDagBuilder}. \texttt{HyperDagBuilder.addVertex}
      then creates a \texttt{PackedVertex} and adds it to the HyperDag. A \texttt{PackedVertex} is a generic vertex type and the parent of other
      vertices such as phantom and epsilon vertices. A regular \texttt{PackedVertex} contains a numeric UID, a \texttt{TaskTemplate}, and an
      \texttt{Option[String]} comment to be used for GraphViz, while a phantom vertex takes \texttt{None} instead of a \texttt{TaskTemplate}, and an
      epsilon vertex takes \texttt{null}.

\item Find Hyperedges that need to be created by calling \texttt{WorkflowBuilder.traverse} on each newly-created \texttt{PackedVertex}. \texttt{traverse}
      is mutually recursive with \texttt{getHyperedges}, which adds a phantom vertex and \texttt{traverse}s that vertex if it encounters a
      nested branch point in the current node's \texttt{BranchPointTreeGrafts}. If it does not encounter a nested branch point, \texttt{getHyperedges}
      adds a phantom vertex for each \texttt{TerminalData} with no temporal dependencies (such as a parameter) and a normal vertex for each
      \texttt{TerminalData} with temporal dependencies (such as an input). In either case, the recursion succeeds, and we are done \texttt{traverse}-ing.

\item Once \texttt{getHyperedges} succeeds, the resulting sequence is passed to a \texttt{PhantomMetaHyperDagBuilder.addMetaEdge}, along with the current
      branch point and a sink vertex. \texttt{PhantomMetaHyperDagBuilder.addMetaEdge} calls \texttt{MetaHyperDagBuilder.addMetaEdge}, which creates a new
      epsilon vertex and \texttt{MetaEdge} and calls \texttt{HyperDagBuilder.addHyperEdge} for each hyperedge in the passed sequence. Epsilon vertices pair
      tasks with their respective branch points. Our minimal example produces eight epsilon vertices: a \texttt{Baseline:task} vertex for each task,
      \texttt{Q:task} vertices for \texttt{hello} and \texttt{parent2}, and \texttt{Sky:task} vertices for \texttt{hello} and \texttt{parent2}. A \texttt{MetaEdge}
      consists of a sink epsilon vertex, the associated branch point, and the sequence of hyperedges. A \texttt{HyperEdge} consists of a numeric UID, a branch,
      and an array of edge labels. These edge labels are isomorphic to the branch's source vertices.

\end{enumerate}


\bibliographystyle{plainnat}
\bibliography{report}

\end{document}

