// This Source Code Form is subject to the terms of the Mozilla Public License, v. 2.0. If a copy of the MPL was not distributed with this file, You can obtain one at http://mozilla.org/MPL/2.0/.

package ducttape.workflow

import collection._
import ducttape.hyperdag.PackedVertex
import ducttape.hyperdag.meta.MetaHyperDag
import ducttape.workflow.Types.UnpackState
import ducttape.workflow.Types.UnpackedWorkVert
import ducttape.workflow.Types.WorkflowEdge
import ducttape.workflow.Types.PackedWorkVert
import ducttape.syntax.Namespace
import ducttape.syntax.AbstractSyntaxTree.Spec
import ducttape.syntax.AbstractSyntaxTree.PackageDef
import ducttape.syntax.AbstractSyntaxTree.SubmitterDef
import ducttape.syntax.AbstractSyntaxTree.VersionerDef
import ducttape.syntax.AbstractSyntaxTree.WorkflowDefinition
import ducttape.hyperdag.HyperEdge
import ducttape.hyperdag.UnpackedVertex
import ducttape.hyperdag.meta.PhantomMetaHyperDag
import ducttape.hyperdag.meta.UnpackedMetaVertex
import ducttape.hyperdag.walker.UnpackedPhantomMetaDagWalker
import ducttape.hyperdag.walker.PackedPhantomMetaDagWalker
import ducttape.hyperdag.walker.MetaVertexFilter
import ducttape.hyperdag.walker.RealizationMunger
import ducttape.hyperdag.walker.Traversal
import ducttape.hyperdag.walker.Arbitrary
import ducttape.workflow.SpecTypes.SpecPair

import grizzled.slf4j.Logging

object HyperWorkflow {
  type ExplainCallback = (=>String, =>String, Boolean) => Unit
  type UnpackedWalker = UnpackedPhantomMetaDagWalker[TaskTemplate,BranchPoint,Branch,SpecGroup,Branch,UnpackState]
  type HyperWorkflowMunger = RealizationMunger[Option[TaskTemplate], Branch, SpecGroup, Branch, UnpackState]
  
/**
 * See also [[ducttape.workflow.Types.UnpackState]] for an explanation
 * of how the UnpackState functions.
 */  
  trait HyperWorkflowStateMunger extends HyperWorkflowMunger {
    
    // heBranch might be None if this vertex has no incoming hyperedge
    override def initHyperedge(heBranch: Option[Branch]): UnpackState = heBranch match {
      case None => UnpackState.empty
      // This line is cool: It cleanly states that branches introduced at a hyperedge
      // are never subject to the grafts of that hyperedge's component edges
      //
      // For example, consider a task t1 that has a realization BP1.b1. We also have a
      // task t2 has an incoming hyperedge that introduces branch BP1.b2, but one of
      // its component edges matches and grafts away BP1.b1 such that it doesn't conflict
      // with BP1.b1. The separation of the hyperedgeState and edgeState allows this.
      // This line also shows that just-introduced branches such as BP1.b2 can never be
      // grafted away by component edges.
      case Some(branch: Branch) => new UnpackState(
        hyperedgeState = UnpackState.emptyMap + ((branch.branchPoint, branch)),
        edgeState = UnpackState.emptyMap)
    }
    
    override def toRealization(state: UnpackState): Seq[Branch] = {
      assert(state.edgeState.isEmpty)
      state.hyperedgeState.values.toSeq
    }
  }
}

// final type parameter TaskDef is for storing the source of input edges
// each element of plan is a set of branches that are mutually compatible
// - not specifying a branch point indicates that any value is acceptable
// TODO: Multimap (just use typedef?)
class HyperWorkflow(val dag: PhantomMetaHyperDag[TaskTemplate,BranchPoint,Branch,SpecGroup],
                    val wd: WorkflowDefinition,
                    val packageDefs: Map[Namespace,PackageDef],
                    val plans: Seq[RealizationPlan],
                    val submitters: Seq[SubmitterDef], // TODO: Resolve earlier?
                    val versioners: Seq[VersionerDef],
                    //val branchPointFactory: BranchPointFactory,
                    val branchFactory: BranchFactory,
                    traversal: Traversal = Arbitrary)
    extends Logging {
  
  import HyperWorkflow._

  val vertexMap = new mutable.HashMap[TaskTemplate, PackedWorkVert]
  for (v: PackedVertex[Option[TaskTemplate]] <- dag.vertices()) {
    val tt: TaskTemplate = v.value.get
    vertexMap += tt -> v
  }

  def toPackedVertex(task: TaskTemplate): PackedWorkVert = vertexMap(task)

  def packedWalker(): PackedPhantomMetaDagWalker[TaskTemplate] = dag.packedWalker

  // TODO: Currently only used by initial pass to find goals
  // TODO: Document different use cases of planFilter vs plannedVertices
  // NOTE: explainCallback can be used to provide the user with
  //       useful information about why certain realizations are not produced
  def NO_EXPLAIN(vertexName: => String, msg: => String, accepted: Boolean) {}
  def unpackedWalker(policy: PlanPolicy,
                     explainCallback: ( =>String, =>String, Boolean) => Unit = NO_EXPLAIN,
                     traversal: Traversal = Arbitrary)
                     : UnpackedWalker = {

    // TODO: XXX: HACK: This shouldn't be called for nulls generated by epsilons
    def toD(branch: Branch): Branch = if (branch != null) branch else Task.NO_BRANCH
    
    def observe(v: UnpackedVertex[Option[TaskTemplate], Branch, SpecGroup, Branch])
      = explainCallback(v.packed.toString, v.realization.mkString(Realization.delimiter), true)

    // the inPlanConstraint implements both a RealizationMunger and a MetaVertexFilter
    val inPlanConstraint = new InPlanConstraint(policy, explainCallback)
      
    // order is important!
    // 1) first, add each edge's state into a holding buffer: edgeState
    // 2) apply grafts
    //    NOTE: some branches may disappear in grafting
    // 3) enforce global branch point consistency 
    // 4) merge the edge state's holding buffer into the hyperedgeState
    // 5) check that the final hyperedge state for plan membership
    val munger = EdgeStateInitializer.
      andThen(new BranchGraftMunger(dag, explainCallback)).
      andThen(GlobalBranchPointConstraint).
      andThen(EdgeStateMerger).
      andThen(inPlanConstraint)
    dag.unpackedWalker[Branch,UnpackState](munger, inPlanConstraint, toD, traversal, observe)(RealizationOrdering)
  }
  
  def toGraphViz(): String = dag.toGraphViz()
  def toGraphVizDebug(): String = dag.toGraphVizDebug()
}
